import fs from 'fs';
import path from 'path';

interface BlogPost {
  slug: string;
  title: string;
  date: string;
  summary: string;
  tags: string[];
  content: string;
}

const CONTENT_DIR = './content';
const GENERATED_DIR = './src/generated';

/**
 * Parses a raw markdown string with frontmatter (YAML-like style)
 * Duplicated from utils/markdown.ts for Node.js compatibility
 */
function parseMarkdownFile(filename: string, text: string): BlogPost {
  const frontMatterRegex = /^---\s*([\s\S]*?)\s*---\s*([\s\S]*)$/;
  const match = frontMatterRegex.exec(text);

  const slug = filename.replace(/\.md$/, '');

  if (!match) {
    return {
      slug,
      title: slug,
      date: 'Unknown',
      summary: '',
      tags: [],
      content: text
    };
  }

  const frontMatterBlock = match[1];
  const content = match[2];

  const metadata: Record<string, string | string[]> = {};
  frontMatterBlock.split('\n').forEach(line => {
    const colonIndex = line.indexOf(':');
    if (colonIndex !== -1) {
      const key = line.slice(0, colonIndex).trim();
      let value = line.slice(colonIndex + 1).trim();
      
      // Handle array syntax [tag1, tag2]
      if (value.startsWith('[') && value.endsWith(']')) {
        metadata[key] = value.slice(1, -1).split(',').map(s => s.trim());
      } else {
        // Remove quotes if present
        value = value.replace(/^['"](.*)['"]$/, '$1');
        metadata[key] = value;
      }
    }
  });

  return {
    slug,
    title: (metadata.title as string) || slug,
    date: (metadata.date as string) || 'Unknown',
    summary: (metadata.summary as string) || '',
    tags: (metadata.tags as string[]) || [],
    content: content.trim()
  };
}

/**
 * Parse date string to comparable value
 * Handles ISO format (YYYY-MM-DD) and legacy formats like "May 2023"
 */
function parseDateForSort(dateStr: string): number {
  // Try ISO format first (YYYY-MM-DD)
  const isoMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateStr);
  if (isoMatch) {
    const [, year, month, day] = isoMatch;
    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day)).getTime();
  }
  
  // Fallback for legacy "Month Year" format
  const date = new Date(dateStr);
  if (!isNaN(date.getTime())) {
    return date.getTime();
  }
  
  return 0;
}

async function buildContent() {
  console.log('üì¶ Building content...');

  // Ensure generated directory exists
  if (!fs.existsSync(GENERATED_DIR)) {
    fs.mkdirSync(GENERATED_DIR, { recursive: true });
  }

  // Process blog posts
  const blogDir = path.join(CONTENT_DIR, 'blog');
  
  if (!fs.existsSync(blogDir)) {
    console.error(`‚ùå Blog directory not found: ${blogDir}`);
    process.exit(1);
  }

  const posts = fs.readdirSync(blogDir)
    .filter(f => f.endsWith('.md'))
    .map(filename => {
      const filePath = path.join(blogDir, filename);
      const content = fs.readFileSync(filePath, 'utf-8');
      return parseMarkdownFile(filename, content);
    })
    .sort((a, b) => {
      const dateA = parseDateForSort(a.date);
      const dateB = parseDateForSort(b.date);
      return dateB - dateA; // Newest first
    });

  console.log(`üìù Found ${posts.length} blog posts`);

  // Generate posts.ts
  const postsOutput = `// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
// Generated by scripts/build-content.ts
// Run "npm run build:content" to regenerate

import type { BlogPost } from '../../types';

export const posts: BlogPost[] = ${JSON.stringify(posts, null, 2)};
`;

  fs.writeFileSync(path.join(GENERATED_DIR, 'posts.ts'), postsOutput);

  console.log('‚úÖ Content built successfully!');
  console.log(`   ‚Üí ${GENERATED_DIR}/posts.ts`);
}

buildContent().catch(err => {
  console.error('‚ùå Build failed:', err);
  process.exit(1);
});

